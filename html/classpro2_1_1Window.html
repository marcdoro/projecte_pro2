<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>My Project: pro2::Window Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(function() { init_search(); });
/* @license-end */
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">My Project
   </div>
  </td>
    <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('classpro2_1_1Window.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classpro2_1_1Window-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">pro2::Window Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="window_8hh_source.html">window.hh</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a64ffe9a6cd8e21cdb17546f7d53a8e0f" id="r_a64ffe9a6cd8e21cdb17546f7d53a8e0f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a64ffe9a6cd8e21cdb17546f7d53a8e0f">Window</a> (std::string title, int <a class="el" href="#a2dae6ae56e14dbec41f724866e1cd898">width</a>, int <a class="el" href="#a3a9de727550a76cd1b33d470f79db00d">height</a>, int zoom=1)</td></tr>
<tr class="memdesc:a64ffe9a6cd8e21cdb17546f7d53a8e0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contruye una ventana con título, anchura y altura.  <br /></td></tr>
<tr class="separator:a64ffe9a6cd8e21cdb17546f7d53a8e0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0a63c4b3d431d8e5e71633b107bbe69" id="r_aa0a63c4b3d431d8e5e71633b107bbe69"><td class="memItemLeft" align="right" valign="top"><a id="aa0a63c4b3d431d8e5e71633b107bbe69" name="aa0a63c4b3d431d8e5e71633b107bbe69"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>~Window</b> ()</td></tr>
<tr class="memdesc:aa0a63c4b3d431d8e5e71633b107bbe69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destruye una ventana, es decir, cierra la ventana abierta en el constructor. <br /></td></tr>
<tr class="separator:aa0a63c4b3d431d8e5e71633b107bbe69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2dae6ae56e14dbec41f724866e1cd898" id="r_a2dae6ae56e14dbec41f724866e1cd898"><td class="memItemLeft" align="right" valign="top"><a id="a2dae6ae56e14dbec41f724866e1cd898" name="a2dae6ae56e14dbec41f724866e1cd898"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>width</b> () const</td></tr>
<tr class="memdesc:a2dae6ae56e14dbec41f724866e1cd898"><td class="mdescLeft">&#160;</td><td class="mdescRight">Devuelve el ancho de la ventana. <br /></td></tr>
<tr class="separator:a2dae6ae56e14dbec41f724866e1cd898"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a9de727550a76cd1b33d470f79db00d" id="r_a3a9de727550a76cd1b33d470f79db00d"><td class="memItemLeft" align="right" valign="top"><a id="a3a9de727550a76cd1b33d470f79db00d" name="a3a9de727550a76cd1b33d470f79db00d"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>height</b> () const</td></tr>
<tr class="memdesc:a3a9de727550a76cd1b33d470f79db00d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Devuelve el alto de la ventana. <br /></td></tr>
<tr class="separator:a3a9de727550a76cd1b33d470f79db00d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a2e9797e7da3874fd62727531e711d6" id="r_a3a2e9797e7da3874fd62727531e711d6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3a2e9797e7da3874fd62727531e711d6">next_frame</a> ()</td></tr>
<tr class="memdesc:a3a2e9797e7da3874fd62727531e711d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gestiona las tareas necesarias para pasar al siguiente fotograma.  <br /></td></tr>
<tr class="separator:a3a2e9797e7da3874fd62727531e711d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb1c39426484aa6776b0cd7d1253932f" id="r_adb1c39426484aa6776b0cd7d1253932f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adb1c39426484aa6776b0cd7d1253932f">clear</a> (Color color=black)</td></tr>
<tr class="memdesc:adb1c39426484aa6776b0cd7d1253932f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rellena la ventana con un color.  <br /></td></tr>
<tr class="separator:adb1c39426484aa6776b0cd7d1253932f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36747221fc49f9b5dcf42d2d7bdf6964" id="r_a36747221fc49f9b5dcf42d2d7bdf6964"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a36747221fc49f9b5dcf42d2d7bdf6964">frame_count</a> () const</td></tr>
<tr class="memdesc:a36747221fc49f9b5dcf42d2d7bdf6964"><td class="mdescLeft">&#160;</td><td class="mdescRight">Devuelve el contador de fotogramas pintados hasta el momento.  <br /></td></tr>
<tr class="separator:a36747221fc49f9b5dcf42d2d7bdf6964"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a475d4644d6f1f082a15bf6b1eaf2631b" id="r_a475d4644d6f1f082a15bf6b1eaf2631b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a475d4644d6f1f082a15bf6b1eaf2631b">is_key_down</a> (int code) const</td></tr>
<tr class="memdesc:a475d4644d6f1f082a15bf6b1eaf2631b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determina si cierta tecla estuvo presionada en el fotograma anterior.  <br /></td></tr>
<tr class="separator:a475d4644d6f1f082a15bf6b1eaf2631b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa4fa6c518d090dcbaca4e6211f35522" id="r_aaa4fa6c518d090dcbaca4e6211f35522"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aaa4fa6c518d090dcbaca4e6211f35522">was_key_pressed</a> (int code) const</td></tr>
<tr class="memdesc:aaa4fa6c518d090dcbaca4e6211f35522"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determina si cierta tecla se presionó entre el fotograma anterior y el actual.  <br /></td></tr>
<tr class="separator:aaa4fa6c518d090dcbaca4e6211f35522"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a261158f414bb77270be1dc7339418e5e" id="r_a261158f414bb77270be1dc7339418e5e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a261158f414bb77270be1dc7339418e5e">is_modkey_down</a> (ModKey key) const</td></tr>
<tr class="memdesc:a261158f414bb77270be1dc7339418e5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determina si cierta tecla de control se presionó entre el fotograma anterior y el actual.  <br /></td></tr>
<tr class="separator:a261158f414bb77270be1dc7339418e5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f3f28c0ff1122e8171534001a1892a3" id="r_a2f3f28c0ff1122e8171534001a1892a3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2f3f28c0ff1122e8171534001a1892a3">is_mouse_down</a> () const</td></tr>
<tr class="memdesc:a2f3f28c0ff1122e8171534001a1892a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determina si el botón izquierdo quedó en estado clicado en el fotograma anterior.  <br /></td></tr>
<tr class="separator:a2f3f28c0ff1122e8171534001a1892a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0950b857d97f12a4a3f9bd082f50dcb" id="r_af0950b857d97f12a4a3f9bd082f50dcb"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af0950b857d97f12a4a3f9bd082f50dcb">was_mouse_pressed</a> () const</td></tr>
<tr class="memdesc:af0950b857d97f12a4a3f9bd082f50dcb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determina si el botón izquierdo del ratón se clicó entre el fotograma anterior y el actual.  <br /></td></tr>
<tr class="separator:af0950b857d97f12a4a3f9bd082f50dcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1362ea74501506424e5b8c4177d19aa1" id="r_a1362ea74501506424e5b8c4177d19aa1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structpro2_1_1Pt.html">Pt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1362ea74501506424e5b8c4177d19aa1">mouse_pos</a> () const</td></tr>
<tr class="memdesc:a1362ea74501506424e5b8c4177d19aa1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Devuelve la posición del cursor del ratón.  <br /></td></tr>
<tr class="separator:a1362ea74501506424e5b8c4177d19aa1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbe66e79c657fd8939c3df975a825214" id="r_abbe66e79c657fd8939c3df975a825214"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abbe66e79c657fd8939c3df975a825214">sleep</a> (int ms) const</td></tr>
<tr class="memdesc:abbe66e79c657fd8939c3df975a825214"><td class="mdescLeft">&#160;</td><td class="mdescRight">Espera que pase un número <code>ms</code> de milisegundos sin hacer nada.  <br /></td></tr>
<tr class="separator:abbe66e79c657fd8939c3df975a825214"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a964b632d53a61b7602dfb909e9b7457f" id="r_a964b632d53a61b7602dfb909e9b7457f"><td class="memItemLeft" align="right" valign="top">Color&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a964b632d53a61b7602dfb909e9b7457f">get_pixel</a> (<a class="el" href="structpro2_1_1Pt.html">Pt</a> xy) const</td></tr>
<tr class="memdesc:a964b632d53a61b7602dfb909e9b7457f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtiene el color de un pixel de la ventana.  <br /></td></tr>
<tr class="separator:a964b632d53a61b7602dfb909e9b7457f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af656aaa062615c33e183199ba2387cac" id="r_af656aaa062615c33e183199ba2387cac"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af656aaa062615c33e183199ba2387cac">set_pixel</a> (<a class="el" href="structpro2_1_1Pt.html">Pt</a> xy, Color color)</td></tr>
<tr class="memdesc:af656aaa062615c33e183199ba2387cac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cambia un pixel de la ventana.  <br /></td></tr>
<tr class="separator:af656aaa062615c33e183199ba2387cac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa39faf0a0dfa480661c314341638548" id="r_aaa39faf0a0dfa480661c314341638548"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aaa39faf0a0dfa480661c314341638548">set_fps</a> (int fps)</td></tr>
<tr class="memdesc:aaa39faf0a0dfa480661c314341638548"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cambia los FPS de refresco de la ventana.  <br /></td></tr>
<tr class="separator:aaa39faf0a0dfa480661c314341638548"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbc70ada8de42a0db90e11e9f3803a1e" id="r_afbc70ada8de42a0db90e11e9f3803a1e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afbc70ada8de42a0db90e11e9f3803a1e">move_camera</a> (<a class="el" href="structpro2_1_1Pt.html">Pt</a> desplazamiento)</td></tr>
<tr class="memdesc:afbc70ada8de42a0db90e11e9f3803a1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indica que la posición de la esquina superior izquierda de la ventana debería moverse según el vector <code>desplazamiento</code>.  <br /></td></tr>
<tr class="separator:afbc70ada8de42a0db90e11e9f3803a1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba9caf9f926e540c6697f690ae6d3c68" id="r_aba9caf9f926e540c6697f690ae6d3c68"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structpro2_1_1Pt.html">Pt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aba9caf9f926e540c6697f690ae6d3c68">camera_center</a> () const</td></tr>
<tr class="memdesc:aba9caf9f926e540c6697f690ae6d3c68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Devuelve la posición del centro de la cámara.  <br /></td></tr>
<tr class="separator:aba9caf9f926e540c6697f690ae6d3c68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fa5335bc584ac503f6ad336314773c3" id="r_a7fa5335bc584ac503f6ad336314773c3"><td class="memItemLeft" align="right" valign="top"><a id="a7fa5335bc584ac503f6ad336314773c3" name="a7fa5335bc584ac503f6ad336314773c3"></a>
<a class="el" href="structpro2_1_1Rect.html">Rect</a>&#160;</td><td class="memItemRight" valign="bottom"><b>camera_rect</b> () const</td></tr>
<tr class="separator:a7fa5335bc584ac503f6ad336314773c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1393bc8d5c74455c1b25e3b38db7af92" id="r_a1393bc8d5c74455c1b25e3b38db7af92"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1393bc8d5c74455c1b25e3b38db7af92">set_camera_topleft</a> (<a class="el" href="structpro2_1_1Pt.html">Pt</a> <a class="el" href="#ada2e1a70077ac2011bd5e2c3716dd96c">topleft</a>)</td></tr>
<tr class="memdesc:a1393bc8d5c74455c1b25e3b38db7af92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Establece la posición de la esquina superior izquierda de la cámara.  <br /></td></tr>
<tr class="separator:a1393bc8d5c74455c1b25e3b38db7af92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada2e1a70077ac2011bd5e2c3716dd96c" id="r_ada2e1a70077ac2011bd5e2c3716dd96c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structpro2_1_1Pt.html">Pt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ada2e1a70077ac2011bd5e2c3716dd96c">topleft</a> () const</td></tr>
<tr class="memdesc:ada2e1a70077ac2011bd5e2c3716dd96c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Devuelve la posición de la esquina superior izquierda de la cámara.  <br /></td></tr>
<tr class="separator:ada2e1a70077ac2011bd5e2c3716dd96c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>La clase <code><a class="el" href="classpro2_1_1Window.html">Window</a></code> permite abrir ventanas en modo gráfico en Linux, MacOS y Windows. Tiene unos pocos métodos que permiten hacer programas simples que muestran gráficos, como pequeños juegos o editores. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a64ffe9a6cd8e21cdb17546f7d53a8e0f" name="a64ffe9a6cd8e21cdb17546f7d53a8e0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64ffe9a6cd8e21cdb17546f7d53a8e0f">&#9670;&#160;</a></span>Window()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pro2::Window::Window </td>
          <td>(</td>
          <td class="paramtype">std::string</td>          <td class="paramname"><span class="paramname"><em>title</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>width</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>height</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>zoom</em></span><span class="paramdefsep"> = </span><span class="paramdefval">1</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Contruye una ventana con título, anchura y altura. </p>
<p>El constructor abre una ventana, y el destructor la cierra.</p>
<p>El parámetro <code>zoom</code> permite visualizar con más comodidad contenido pixelado. Con <code>zoom = 1</code> cada pixel de la ventana se corresponde con un pixel de la pantalla. Con <code>zoom = 3</code>, cada píxel de la ventana se convierte en un cuadrado de 3x3 píxeles en la ventana.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">title</td><td>El título de la ventana (un literal de cadena de caracteres) </td></tr>
    <tr><td class="paramname">width</td><td>El ancho de la ventana en píxels. </td></tr>
    <tr><td class="paramname">height</td><td>El alto de la ventana en píxels. </td></tr>
    <tr><td class="paramname">zoom</td><td>El factor de aumento de cada píxel. (Es opcional, si no hay 4o parámetro toma valor 1) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="aba9caf9f926e540c6697f690ae6d3c68" name="aba9caf9f926e540c6697f690ae6d3c68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba9caf9f926e540c6697f690ae6d3c68">&#9670;&#160;</a></span>camera_center()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structpro2_1_1Pt.html">Pt</a> pro2::Window::camera_center </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Devuelve la posición del centro de la cámara. </p>
<dl class="section return"><dt>Returns</dt><dd>Un <code><a class="el" href="structpro2_1_1Pt.html">Pt</a></code> con las coordenadas del centro de la cámara. </dd></dl>

</div>
</div>
<a id="adb1c39426484aa6776b0cd7d1253932f" name="adb1c39426484aa6776b0cd7d1253932f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb1c39426484aa6776b0cd7d1253932f">&#9670;&#160;</a></span>clear()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pro2::Window::clear </td>
          <td>(</td>
          <td class="paramtype">Color</td>          <td class="paramname"><span class="paramname"><em>color</em></span><span class="paramdefsep"> = </span><span class="paramdefval">black</span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Rellena la ventana con un color. </p>
<p>Este método se puede llamar con un color o bien sin parámetros. Si se llama sin parámetros se toma el <code>color</code> por defecto, que es el negro (<code>black</code>). De lo contrario se usa el color indicado.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">color</td><td>El color a utilizar para pintar. Se puede usar uno de los valores del enumerado <code>Colors</code>, como <code>red</code>, o bien poner un entero en hexadecimal, como 0x0084fb, que equivale a los 3 valores RGB (o Red-Green-Blue) que conforman el color. Cualquier "color
picker" de la web suele mostrar el color hexadecimal en la notación <code>#0084fb</code> (de CSS). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a36747221fc49f9b5dcf42d2d7bdf6964" name="a36747221fc49f9b5dcf42d2d7bdf6964"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36747221fc49f9b5dcf42d2d7bdf6964">&#9670;&#160;</a></span>frame_count()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int pro2::Window::frame_count </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Devuelve el contador de fotogramas pintados hasta el momento. </p>
<p>Equivale a la cantidad de veces que se ha llamado a <code>next_frame</code>. Se incrementa en 1 unidad en cada fotograma.</p>
<p>Este valor es útil al hacer animaciones, ya que permite saber, de una secuencia de imágenes, cuál habría que usar en cada momento.</p>
<dl class="section return"><dt>Returns</dt><dd>Un entero que corresponde al contador de fotogramas mostrados desde que la ventana se creó. </dd></dl>

</div>
</div>
<a id="a964b632d53a61b7602dfb909e9b7457f" name="a964b632d53a61b7602dfb909e9b7457f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a964b632d53a61b7602dfb909e9b7457f">&#9670;&#160;</a></span>get_pixel()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Color pro2::Window::get_pixel </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpro2_1_1Pt.html">Pt</a></td>          <td class="paramname"><span class="paramname"><em>xy</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Obtiene el color de un pixel de la ventana. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xy</td><td>Coordenadas del pixel de la pantalla del que se quiere saber el color. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>El color del pixel en las coordenadas indicadas. </dd></dl>

</div>
</div>
<a id="a475d4644d6f1f082a15bf6b1eaf2631b" name="a475d4644d6f1f082a15bf6b1eaf2631b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a475d4644d6f1f082a15bf6b1eaf2631b">&#9670;&#160;</a></span>is_key_down()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool pro2::Window::is_key_down </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>code</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determina si cierta tecla estuvo presionada en el fotograma anterior. </p>
<p>El método <code>next_frame</code> recoge todas los eventos de teclado y ratón que han ocurrido desde la llamada anterior a <code>next_frame</code> (o desde la creación de la ventana) y mantiene el estado de todas las teclas y botones del ratón fijo durante el fotograma actual. Así pues, el método <code>is_key_down</code> simplemente consulta ese estado, que se mantiene fijo hasta la siguiente llamada a <code>next_frame</code>.</p>
<p>Ejemplo: </p><div class="fragment"><div class="line"><span class="keywordflow">if</span> (window.is_key_down(<span class="charliteral">&#39;S&#39;</span>)) { ... }</div>
<div class="line"><span class="keywordflow">if</span> (window.is_key_down(<span class="charliteral">&#39;1&#39;</span>)) { ... }</div>
<div class="line"><span class="keywordflow">if</span> (window.is_key_down(Key::Escape)) { ... }</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">code</td><td>El código de la tecla de la que se quiere saber si estaba presionada. El código de la letra es, o bien el código ASCII de la letra mayúscula correspondiente, el código ASCII del dígito correspondiente, o bien uno de los valores del <code>enum</code> <code>Key</code>, que recoge las teclas más típicas, incluyendo flechas, return, esc, tab, etc.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> cuando la tecla <code>code</code> estaba presionada al empezar el fotograma actual. </dd></dl>

</div>
</div>
<a id="a261158f414bb77270be1dc7339418e5e" name="a261158f414bb77270be1dc7339418e5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a261158f414bb77270be1dc7339418e5e">&#9670;&#160;</a></span>is_modkey_down()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool pro2::Window::is_modkey_down </td>
          <td>(</td>
          <td class="paramtype">ModKey</td>          <td class="paramname"><span class="paramname"><em>key</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determina si cierta tecla de control se presionó entre el fotograma anterior y el actual. </p>
<p>Método análogo a <code>is_key_down</code> pero para las teclas de control siguientes: Ctrl, Alt, Shift y Meta. Hay un enumerado de nombre <code>ModKey</code> con las 4 teclas: <code>ModKey::Ctrl</code>, <code>ModKey::Alt</code>, <code>ModKey::Shift</code>, y <code>ModKey::Meta</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>La tecla de la que se quiere consultar el estado.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> si el estado de la tecla era "presionado" al entrar al fotograma actual. </dd></dl>

</div>
</div>
<a id="a2f3f28c0ff1122e8171534001a1892a3" name="a2f3f28c0ff1122e8171534001a1892a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f3f28c0ff1122e8171534001a1892a3">&#9670;&#160;</a></span>is_mouse_down()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool pro2::Window::is_mouse_down </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determina si el botón izquierdo quedó en estado clicado en el fotograma anterior. </p>
<p>Este método se comporta como <code>is_key_down</code>, consulta la documentación de <code>is_key_down</code> para saber cómo opera.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> si el botón del ratón quedó clicado al final del fotograma actual. </dd></dl>

</div>
</div>
<a id="a1362ea74501506424e5b8c4177d19aa1" name="a1362ea74501506424e5b8c4177d19aa1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1362ea74501506424e5b8c4177d19aa1">&#9670;&#160;</a></span>mouse_pos()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structpro2_1_1Pt.html">Pt</a> pro2::Window::mouse_pos </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Devuelve la posición del cursor del ratón. </p>
<dl class="section return"><dt>Returns</dt><dd>Una tupla de tipo <code><a class="el" href="structpro2_1_1Pt.html">Pt</a></code>, con campos <code>x</code> e <code>y</code>, que se corresponden con las coordenadas de la posición del ratón. </dd></dl>

</div>
</div>
<a id="afbc70ada8de42a0db90e11e9f3803a1e" name="afbc70ada8de42a0db90e11e9f3803a1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afbc70ada8de42a0db90e11e9f3803a1e">&#9670;&#160;</a></span>move_camera()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pro2::Window::move_camera </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpro2_1_1Pt.html">Pt</a></td>          <td class="paramname"><span class="paramname"><em>desplazamiento</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Indica que la posición de la esquina superior izquierda de la ventana debería moverse según el vector <code>desplazamiento</code>. </p>
<p>La cámara no se mueve instantáneamente, sino que se desplaza a la nueva posición a una velocidad constante.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">desplazamiento</td><td>Vector de desplazamiento </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3a2e9797e7da3874fd62727531e711d6" name="a3a2e9797e7da3874fd62727531e711d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a2e9797e7da3874fd62727531e711d6">&#9670;&#160;</a></span>next_frame()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool pro2::Window::next_frame </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gestiona las tareas necesarias para pasar al siguiente fotograma. </p>
<p>En todo programa gráfico es necesario: 1) pintar en una superfície, típicamente en memoria, 2) transferir lo que se ha pintado a la pantalla, 3) procesar eventos ocurridos como presión de teclas o movimiento del ratón y actualizar su estado, y 4) esperar el tiempo que quede hasta el siguiente fotograma (en función de la velocidad de refresco, que suele ser de 60Hz, lo que equivale a 16ms por fotograma).</p>
<p><code>next_frame</code> hace todas estas cosas en una sola llamada. Además devuelve <code>false</code> cuando se ha clicado el botón de cerrar la ventana (típicamente arriba a la derecha, y con una "x"), de forma que se pueda saber si se debe continuar en un bucle de pintado de fotogramas.</p>
<p>El uso típico es el siguiente: </p><div class="fragment"><div class="line"><span class="keywordflow">while</span> (window.next_frame()) {</div>
<div class="line">    <span class="comment">// usar los métodos de detección de teclas o ratón, y set_pixel para pintar...</span></div>
<div class="line">}</div>
</div><!-- fragment --><p> Es decir, hasta que no se cierre la ventana llamamos métodos de la ventana para hacer operaciones que resulten en el pintado de la ventana de cierta manera y <code>next_frame</code> se hace cargo del resto.</p>
<p>Con respecto al teclado y ratón, <code>next_frame</code> recoge todos los eventos (presión y soltado de teclas, clicks y movimiento del ratón) que han ocurrido entre el fotograma anterior y el actual, y con todos ellos actualiza el estado final de cada tecla, botón del ratón y posición. Así pues, el usuario de la clase <code><a class="el" href="classpro2_1_1Window.html">Window</a></code> tiene acceso al estado exacto de las teclas y el ratón en el instante en que se pasa al fotograma actual, y ese estado se conserva fijo mientras transcurre el tiempo entre el fotograma actual y el siguiente, en el que <code>next_frame</code> vuelve a revisar los eventos ocurridos en ese intervalo de tiempo.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> si el programa debe seguir (NO se ha clicado el botón de cerrar la ventana), <code>false</code> en caso contrario. </dd></dl>

</div>
</div>
<a id="a1393bc8d5c74455c1b25e3b38db7af92" name="a1393bc8d5c74455c1b25e3b38db7af92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1393bc8d5c74455c1b25e3b38db7af92">&#9670;&#160;</a></span>set_camera_topleft()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pro2::Window::set_camera_topleft </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpro2_1_1Pt.html">Pt</a></td>          <td class="paramname"><span class="paramname"><em>topleft</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Establece la posición de la esquina superior izquierda de la cámara. </p>
<p>Este método mueve la cámara instantáneamente a la nueva posición.Alt</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">topleft</td><td>La nueva posición absoluta de la cámara, que se aplica instantáneamente. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aaa39faf0a0dfa480661c314341638548" name="aaa39faf0a0dfa480661c314341638548"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa39faf0a0dfa480661c314341638548">&#9670;&#160;</a></span>set_fps()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pro2::Window::set_fps </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>fps</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Cambia los FPS de refresco de la ventana. </p>
<p>En función de la velocidad de refresco de la pantalla que queramos, el tiempo a esperar entre que pintamos un fotograma y el siguiente puede variar. Este método calcula un tiempo de espera entre una llamada a <code>next_frame</code> y la siguiente, para que se produzca exactamente un número de fotogramas por segundo.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fps</td><td>Número de fotogramas por segundo que se quieren mostrar.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>fps</code> &gt; 0 &amp;&amp; <code>fps</code> &lt; 240. </dd></dl>

</div>
</div>
<a id="af656aaa062615c33e183199ba2387cac" name="af656aaa062615c33e183199ba2387cac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af656aaa062615c33e183199ba2387cac">&#9670;&#160;</a></span>set_pixel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pro2::Window::set_pixel </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpro2_1_1Pt.html">Pt</a></td>          <td class="paramname"><span class="paramname"><em>xy</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Color</td>          <td class="paramname"><span class="paramname"><em>color</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Cambia un pixel de la ventana. </p>
<p>En realidad, <code>set_pixel</code> no cambia la ventana directamente, sinó un "buffer" interno que se vuelca en la pantalla de golpe en el momento de llamar a <code>next_frame</code>. Esto es más eficiente y maximiza el tiempo en que el fotograma está inmóvil en la pantalla mostrando una imagen fija, ya que el pintado podría llevar tanto tiempo que los fotogramas no se verían completos en la pantalla durante los 16ms (a 60Hz) en que deben estar visibles.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xy</td><td>Coordenadas del pixel que se quiere cambiar </td></tr>
    <tr><td class="paramname">color</td><td>Color que se quiere poner en el pixel indicado </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abbe66e79c657fd8939c3df975a825214" name="abbe66e79c657fd8939c3df975a825214"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abbe66e79c657fd8939c3df975a825214">&#9670;&#160;</a></span>sleep()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pro2::Window::sleep </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>ms</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Espera que pase un número <code>ms</code> de milisegundos sin hacer nada. </p>
<p>En ese intervalo de tiempo el programa estará esperando que el método vuelva de la llamada, y por tanto no se ejecutará ninguna instrucción.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ms</td><td>Número de milisegundos a esperar. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ada2e1a70077ac2011bd5e2c3716dd96c" name="ada2e1a70077ac2011bd5e2c3716dd96c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada2e1a70077ac2011bd5e2c3716dd96c">&#9670;&#160;</a></span>topleft()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structpro2_1_1Pt.html">Pt</a> pro2::Window::topleft </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Devuelve la posición de la esquina superior izquierda de la cámara. </p>
<dl class="section return"><dt>Returns</dt><dd>Un <code><a class="el" href="structpro2_1_1Pt.html">Pt</a></code> con las coordenadas de la esquina superior izquierda de la cámara. </dd></dl>

</div>
</div>
<a id="aaa4fa6c518d090dcbaca4e6211f35522" name="aaa4fa6c518d090dcbaca4e6211f35522"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa4fa6c518d090dcbaca4e6211f35522">&#9670;&#160;</a></span>was_key_pressed()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool pro2::Window::was_key_pressed </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>code</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determina si cierta tecla se presionó entre el fotograma anterior y el actual. </p>
<p>(En el método <code>is_key_down</code> se explica mejor el funcionamiento de los eventos.)</p>
<p>Ejemplo: </p><div class="fragment"><div class="line"><span class="keywordflow">if</span> (window.was_key_pressed(<span class="charliteral">&#39;S&#39;</span>)) { ... }</div>
<div class="line"><span class="keywordflow">if</span> (window.was_key_pressed(<span class="charliteral">&#39;1&#39;</span>)) { ... }</div>
<div class="line"><span class="keywordflow">if</span> (window.was_key_pressed(Key::Escape)) { ... }</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">code</td><td>El código de la tecla de la que se quiere saber si estaba presionada. El código de la letra es, o bien el código ASCII de la letra mayúscula correspondiente, el código ASCII del dígito correspondiente, o bien uno de los valores del <code>enum</code> <code>Key</code>, que recoge las teclas más típicas, incluyendo flechas, return, esc, tab, etc.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> cuando la tecla <code>code</code> estaba presionada al empezar el fotograma actual. </dd></dl>

</div>
</div>
<a id="af0950b857d97f12a4a3f9bd082f50dcb" name="af0950b857d97f12a4a3f9bd082f50dcb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0950b857d97f12a4a3f9bd082f50dcb">&#9670;&#160;</a></span>was_mouse_pressed()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool pro2::Window::was_mouse_pressed </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determina si el botón izquierdo del ratón se clicó entre el fotograma anterior y el actual. </p>
<p>Este método se comporta como <code>was_key_pressed</code>, consulta la documentación de <code>was_key_pressed</code> para saber cómo opera.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> si el botón del ratón se clicó entre el fotograma anterior y el actual. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="window_8hh_source.html">window.hh</a></li>
<li><b>window.cc</b></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><b>pro2</b></li><li class="navelem"><a class="el" href="classpro2_1_1Window.html">Window</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.13.2 </li>
  </ul>
</div>
</body>
</html>
